% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plspm_interaction.R
\name{plspm_interaction}
\alias{plspm_interaction}
\title{PLS-PMinteraction effect  Partial Least Squares Path Modeling}
\usage{
plspm_interaction(
  Data,
  path_matrix,
  blocks,
  interactionTerm = NULL,
  indicator_prod = NULL,
  inter_modes = NULL,
  method = "two_stage",
  modes = rep("A", ncol(path_matrix)),
  scaling = NULL,
  scheme = "centroid",
  scaled = TRUE,
  tol = 1e-06,
  maxiter = 100,
  plscomp = NULL,
  boot.val = TRUE,
  br = 500,
  seed = NULL,
  dataset = TRUE
)
}
\arguments{
\item{Data}{matrix or data frame containing the manifest variables.}

\item{path_matrix}{A square (lower triangular) boolean matrix
representing the inner model (i.e. the path relationships between latent variables).}

\item{blocks}{list of vectors with column indices
or column names from Data indicating the sets of
manifest variables forming each block (i.e.
which manifest variables correspond to each block).#'}

\item{interactionTerm}{interaction terms}

\item{indicator_prod}{indicator producst}

\item{inter_modes}{new modes auto or direct input}

\item{method}{Two_stage, indicator}

\item{modes}{optional argument for runing the non-metric approach;
it is a list of string vectors indicating the type of measurement
scale for each manifest variable specified in blocks. scaling must be
specified when working with non-metric variables. Possible values:
"num" (linear transformation, suitable for numerical variables),
"raw" (no transformation), "nom" (non-monotonic transformation,
suitable for nominal variables), and "ord" (monotonic transformation,
suitable for ordinal variables).}

\item{scaling}{character vector indicating the type of measurement f
or each block. Possible values are: "A", "B", "newA", "PLScore",
"PLScow". The length of modes must be equal to the length of blocks.}

\item{scheme}{string indicating the type of inner weighting scheme.
Possible values are "centroid", "factorial", or "path".}

\item{scaled}{standardized. Only used when scaling = NULL.
When (TRUE, data is scaled to standardized values (mean=0 and variance=1).
 The variance is calculated dividing by N instead of N-1).}

\item{tol}{decimal value indicating the tolerance criterion
for the iterations (tol=0.000001). Can be specified between 0 and 0.001.}

\item{maxiter}{integer indicating the maximum number of iterations
(maxiter=100 by default). The minimum value of maxiter is 100.}

\item{plscomp}{optional vector indicating the number of PLS components
(for each block) to be used when handling non-metric data
(only used if scaling is provided)}

\item{boot.val}{whether bootstrap validation should be performed.
(FALSE by default).}

\item{br}{number bootstrap resamples. Used only when boot.val=TRUE. When boot.val=TRUE, the default number of re-samples is 100.}

\item{dataset}{whether the data matrix used in the computations should be retrieved (TRUE by default).}
}
\value{
resutl
}
\description{
PLS-PMinteraction effect  Partial Least Squares Path Modeling
}
\examples{


\dontrun{
#'

data(satisfaction)
sat_path3 = plspm_paths(
  row_names = c("IMAG","EXPE","QUAL","VAL","SAT","LOY"),
  relationship = list(
    path(from="IMAG", to=c("EXPE","SAT","LOY")),
    path("EXPE", c("QUAL","VAL","SAT")),
    path("QUAL", c("VAL","SAT")),
    path("VAL",c("SAT")),
    path("SAT","LOY"))
)

sat_path2

# blokcs
sat_blocks1 <- plspm_blocks(
  IMAG = item(paste0("imag",1:5)),
  EXPE = item(paste0("expe", 1:5)),
  QUAL = item( paste0("qual", 1:5)),
  VAL = item(paste0("val", 1:4)),
  SAT = item(paste0("sat", 1:4)),
  LOY = item(paste0("loy", 1:4))
)

sat_blocks1

# vector of modes (reflective indicators):auto
sat_mod = rep("A", 6)

resinter = plspm_interaction(Data=satisfaction,
                     sat_path2, blocks = sat_blocks1, modes= sat_mod,
                     interactionTerm = list(list(from = "IMAG*EXPE", to = "LOY"),
                     list(from = "IMAG*QUAL", to = "LOY")))
resinter\%>\%summary()
x11()
plot(resinter)

# resinter \%>\%plspm_boot_effect()\%>\%cut_print(rm_row=TRUE)
resinter \%>\%plspm_effect()\%>\%cut_print(rm_row=TRUE)

plspm_paths_sig(resinter, unite=TRUE)
plspm_paths_sig_plot(resinter)
plspm_path_coefs_plot(resinter)

plspm_semPaths2(resinter, structural = T)


#'
## Two stage approach
pls_ts = plspm_interaction(satisfaction, sat_path2, sat_blocks1,
               interactionTerm = list(list(from = "IMAG*EXPE", to = "LOY")) ,
               indicator_prod = list(intIE = interlist("IMAG",1,2, "EXPE",1,2)),
               method="two_stage")
pls_ts \%>\%summary()


plspm_path_coefs_plot(pls_ts,"circle")
plspm_semPaths2(pls_ts)

# plspm_boot_factor_layout(pls_ts)

## indicator arpproach
pls_int = plspm_interaction(satisfaction, sat_path2, sat_blocks1,
                  interactionTerm = list(list(from = "IMAG*EXPE", to = "LOY")) ,
                indicator_prod = list(intIE = interlist("IMAG", "EXPE")),
                  method="indicator")
pls_int \%>\%summary()


plspm_path_coefs_plot(pls_int, "circle")
plspm_path_coefs_plot(pls_int)
plspm_semPaths2(pls_int)
#'
#'


}


}
